/**
 * Plugin Executor
 *
 * Executes plugins and inserts generated content into schemas.
 */

import type {
	ParsedSchema,
	PluginContext,
	PluginExecutionResult,
} from "../types";
import { getPlugin } from "./registry";

/**
 * Execute all plugins for a schema
 */
export async function executePlugins(
	schema: ParsedSchema,
): Promise<PluginExecutionResult[]> {
	const results: PluginExecutionResult[] = [];

	for (const pluginDirective of schema.plugins) {
		const plugin = getPlugin(pluginDirective.name);

		if (!plugin) {
			console.warn(`Plugin not found: ${pluginDirective.name}`);
			continue;
		}

		// Validate config
		if (plugin.validate && !plugin.validate(pluginDirective.config)) {
			throw new Error(
				`Invalid configuration for plugin: ${pluginDirective.name}`,
			);
		}

		// Build plugin context
		const context: PluginContext = {
			schemaPath: schema.filePath,
			namespace: schema.dbSchema,
			provider: schema.datasource?.provider || "postgresql",
		};

		// Execute plugin
		const content = await plugin.generate(pluginDirective.config, context);

		// Count models and enums
		const modelCount = (content.match(/^model\s+\w+/gm) || []).length;
		const enumCount = (content.match(/^enum\s+\w+/gm) || []).length;

		results.push({
			pluginName: pluginDirective.name,
			content,
			timestamp: new Date().toISOString(),
			metadata: {
				source: pluginDirective.config.source as string | undefined,
				modelCount,
				enumCount,
			},
		});
	}

	return results;
}

/**
 * Insert plugin content into schema with boundaries
 */
export function insertPluginContent(
	schemaContent: string,
	pluginResults: PluginExecutionResult[],
): string {
	if (pluginResults.length === 0) {
		return schemaContent;
	}

	// Find insertion point (after datasource/generator, before first model)
	const lines = schemaContent.split("\n");
	let insertionIndex = 0;

	// Find last generator or datasource block
	for (let i = 0; i < lines.length; i++) {
		if (lines[i].includes("datasource ") || lines[i].includes("generator ")) {
			// Find closing brace
			for (let j = i; j < lines.length; j++) {
				if (lines[j].includes("}")) {
					insertionIndex = j + 1;
					break;
				}
			}
		}
	}

	// Skip empty lines after insertion point
	while (insertionIndex < lines.length && lines[insertionIndex].trim() === "") {
		insertionIndex++;
	}

	// Build plugin sections
	const pluginSections: string[] = [];

	for (const result of pluginResults) {
		const section = generatePluginBoundary(result);
		pluginSections.push(section);
	}

	// Insert plugin sections
	const before = lines.slice(0, insertionIndex).join("\n");
	const after = lines.slice(insertionIndex).join("\n");

	return [before, ...pluginSections, after]
		.filter((s) => s.trim())
		.join("\n\n");
}

/**
 * Generate plugin boundary with content
 */
function generatePluginBoundary(result: PluginExecutionResult): string {
	const { pluginName, content, timestamp, metadata } = result;

	const sections: string[] = [];

	// Start marker
	sections.push(
		`// ============================================================================`,
	);
	sections.push(`// GENERATED BY PLUGIN: ${pluginName}`);

	if (metadata.source) {
		sections.push(`// Source: ${metadata.source}`);
	}

	sections.push(`// Last updated: ${timestamp}`);

	if (metadata.modelCount !== undefined) {
		sections.push(
			`// Generated: ${metadata.modelCount} model(s), ${metadata.enumCount || 0} enum(s)`,
		);
	}

	sections.push(
		`// ============================================================================`,
	);

	// Plugin content
	sections.push("");
	sections.push(content);
	sections.push("");

	// End marker
	sections.push(
		`// ============================================================================`,
	);
	sections.push(`// END PLUGIN GENERATED: ${pluginName}`);
	sections.push(
		`// ============================================================================`,
	);

	return sections.join("\n");
}

/**
 * Remove existing plugin boundaries from schema
 */
export function removePluginBoundaries(content: string): string {
	const lines = content.split("\n");
	const result: string[] = [];
	let inPluginBoundary = false;
	let currentPlugin: string | null = null;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];

		// Check for plugin boundary start
		const startMatch = /^\/\/\s*={70,}/.exec(line);
		if (startMatch && i + 1 < lines.length) {
			const nextLine = lines[i + 1];
			const pluginMatch = /^\/\/\s*GENERATED BY PLUGIN:\s*(.+)/i.exec(nextLine);

			if (pluginMatch) {
				inPluginBoundary = true;
				currentPlugin = pluginMatch[1].trim();
				continue; // Skip this line
			}
		}

		// Check for plugin boundary end
		if (inPluginBoundary && currentPlugin) {
			const endMatch = new RegExp(
				`^//\\s*END PLUGIN GENERATED:\\s*${currentPlugin}`,
				"i",
			).exec(line);

			if (endMatch) {
				// Skip this line and the next separator line
				i++; // Skip the === line after END PLUGIN
				inPluginBoundary = false;
				currentPlugin = null;
				continue;
			}
		}

		// Skip lines inside plugin boundary
		if (inPluginBoundary) {
			continue;
		}

		result.push(line);
	}

	return result.join("\n");
}
